---
- name: Define dsconf candidate paths
  ansible.builtin.set_fact:
    dirsrv_dsconf_candidates:
      - /usr/sbin/dsconf
      - /sbin/dsconf
      - dsconf
  tags: [preflight]

- name: Stat dsconf candidates
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dirsrv_dsconf_candidates }}"
  register: dirsrv_dsconf_stats
  tags: [preflight]

- name: Assert dsconf is present
  ansible.builtin.assert:
    that:
      - (dirsrv_dsconf_stats.results | selectattr('stat.exists', 'equalto', true) | list | length) > 0
    fail_msg: "dsconf not found. Ensure 389-DS tools are installed."
  tags: [preflight]

- name: Select dsconf binary path
  ansible.builtin.set_fact:
    dirsrv_dsconf_bin: "{{ (dirsrv_dsconf_stats.results | selectattr('stat.exists', 'equalto', true) | map(attribute='stat.path') | list | first) | default('dsconf') }}"
  tags: [preflight]

- name: Probe dsconf export help
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsconf_bin }}", "{{ dirsrv_instance }}", "backend", "export", "--help"]
  register: dirsrv_src_dsconf_export_help
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Probe dsconf import help
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsconf_bin }}", "{{ dirsrv_instance }}", "backend", "import", "--help"]
  register: dirsrv_tgt_dsconf_import_help
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Derive dsconf capability flags
  ansible.builtin.set_fact:
    dirsrv_dsconf_supports_suffix: >-
      {{ ((dirsrv_src_dsconf_export_help.stdout | default('')) + ' ' + (dirsrv_src_dsconf_export_help.stderr | default(''))
          + ' ' + (dirsrv_tgt_dsconf_import_help.stdout | default('')) + ' ' + (dirsrv_tgt_dsconf_import_help.stderr | default(''))) is search('\\-\\-suffix') }}
    dirsrv_dsconf_supports_timeout_export: >-
      {{ ((dirsrv_src_dsconf_export_help.stdout | default('')) + ' ' + (dirsrv_src_dsconf_export_help.stderr | default(''))) is search('\\-\\-timeout') }}
    dirsrv_dsconf_supports_timeout_import: >-
      {{ ((dirsrv_tgt_dsconf_import_help.stdout | default('')) + ' ' + (dirsrv_tgt_dsconf_import_help.stderr | default(''))) is search('\\-\\-timeout') }}
  tags: [preflight]

- name: Build dsconf timeout argv (export)
  ansible.builtin.set_fact:
    dirsrv_dsconf_export_timeout_args: "{{ ['--timeout', (dirsrv_dsconf_timeout | string)] if (dirsrv_dsconf_supports_timeout_export | default(false)) else [] }}"
  tags: [preflight]

- name: Build dsconf timeout argv (import)
  ansible.builtin.set_fact:
    dirsrv_dsconf_import_timeout_args: "{{ ['--timeout', (dirsrv_dsconf_timeout | string)] if (dirsrv_dsconf_supports_timeout_import | default(false)) else [] }}"
  tags: [preflight]

# Optional discovery: effective instance/socket derived from dsctl when present
- name: Preflight | Discover dsctl candidates
  ansible.builtin.set_fact:
    dirsrv_dsctl_candidates:
      - /usr/sbin/dsctl
      - /sbin/dsctl
      - dsctl
  tags: [preflight]

- name: Preflight | Stat dsctl candidates
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dirsrv_dsctl_candidates }}"
  register: dirsrv_dsctl_stats
  changed_when: false
  tags: [preflight]

- name: Preflight | Select dsctl binary path
  ansible.builtin.set_fact:
    dirsrv_dsctl_bin: "{{ (dirsrv_dsctl_stats.results | selectattr('stat.exists', 'equalto', true) | map(attribute='stat.path') | list | first) | default('dsctl') }}"
  tags: [preflight]

- name: Preflight | Detect instances via dsctl -l
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsctl_bin }}", "-l"]
  register: _dsctl_list
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Preflight | Derive detected instance name from dsctl output
  ansible.builtin.set_fact:
    _dirsrv_instance_detected: >-
      {{ (((_dsctl_list.stdout | default('')) | trim) == 'slapd-localhost')
          | ternary('localhost', 'dir') }}
  tags: [preflight]

- name: Preflight | Set effective instance
  ansible.builtin.set_fact:
    dirsrv_instance_effective: >-
      {{ (dirsrv_instance is defined and (dirsrv_instance | string | length) > 0)
          | ternary(dirsrv_instance, _dirsrv_instance_detected) }}
  tags: [preflight]

- name: Preflight | Set effective ldapi socket path
  ansible.builtin.set_fact:
    dirsrv_ldapi_socket_path_effective: >-
      {{ (dirsrv_ldapi_socket_path is defined and (dirsrv_ldapi_socket_path | string | length) > 0)
          | ternary(dirsrv_ldapi_socket_path,
                    '/var/run/dirsrv/slapd-' ~ (dirsrv_instance_effective) ~ '.socket') }}
  tags: [preflight]

# DNS/TCP gating for replication targets (runs when replication topology data present)
- name: Preflight | Collect replication targets
  ansible.builtin.set_fact:
    __dirsrv_unique_targets: "{{ (dirsrv_repl_agreements | default({}) | dict2items | map(attribute='value') | flatten | selectattr('from', 'equalto', inventory_hostname) | map(attribute='to') | unique | list) }}"
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - dirsrv_repl_nodes is defined
  tags: [preflight]

- name: Preflight | Enforce addressing policy by environment (containers vs VMs)
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import re, json, sys
        nodes = json.loads('''{{ dirsrv_repl_nodes | default({}) | to_json }}''')
        tt_all = '''{{ dirsrv_target_type | default('vm') }}'''
        if not isinstance(nodes, dict) or not nodes:
            sys.exit(0)
        v4 = re.compile(r"^(?:\d{1,3}\.){3}\d{1,3}$")
        v6 = re.compile(r"^[0-9A-Fa-f:]+(?::[0-9A-Fa-f:]*)+$")
        svc = re.compile(r"^[a-zA-Z0-9-]+$")
        dsnet = re.compile(r"^[a-zA-Z0-9-]+\.dsnet\.test$")
        fqdnp = re.compile(r"^[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+$")
        errors = []
        for name, info in nodes.items():
            host = str(info.get('host','')).strip()
            tt = tt_all or 'vm'
            if not host:
                errors.append(f"{name}: host is empty")
                continue
            if v4.match(host) or v6.match(host):
                errors.append(f"{name}: IP literal not allowed in dirsrv_repl_nodes['{name}'].host ({host})")
                continue
            if tt == 'container':
                if not (svc.match(host) or dsnet.match(host)):
                    errors.append(f"{name}: container host must be a Compose service name or *.dsnet.test (got: {host})")
            else:
                if not fqdnp.match(host):
                    errors.append(f"{name}: VM host must be FQDN (got: {host})")
                elif host.endswith('.dsnet.test'):
                    errors.append(f"{name}: VM host may not be under dsnet.test (got: {host})")
        if errors:
            print("Addressing policy violations detected:\n - " + "\n - ".join(errors))
            print("Fix: containers â†’ service name or *.dsnet.test; VMs â†’ FQDN (no IPs). See AGENTS.md.")
            sys.exit(1)
        sys.exit(0)
  register: __addr_policy_check
  changed_when: false
  failed_when: __addr_policy_check.rc != 0
  when:
    - dirsrv_repl_nodes is defined
    - dirsrv_repl_nodes | length > 0
  tags: [preflight, network_validation]

- name: Preflight | Get authoritative container network information from Podman
  ansible.builtin.command:
    argv:
      - podman
      - network
      - inspect
      - "{{ dirsrv_repl_network | default('dsnet') }}"
      - --format
      - json
  register: __podman_network_info
  changed_when: false
  failed_when: false  # Don't fail if podman not available (e.g., inside containers)
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - (dirsrv_target_type | default('vm')) == 'container'
    - (dirsrv_network_validate | default(true)) | bool
  tags: [preflight, network_validation]

- name: Preflight | Extract container IP mappings from Podman network
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import json
        import sys

        try:
            # Parse Podman network inspection output
            network_data = json.loads('{{ __podman_network_info.stdout | to_json }}')
            containers = network_data[0]['containers']

            # Build mapping of container names to IPs
            container_map = {}
            for container_id, container_info in containers.items():
                name = container_info['name']
                # Extract IP from eth0 interface (remove /24 subnet mask)
                ip_with_mask = container_info['interfaces']['eth0']['subnets'][0]['ipnet']
                ip = ip_with_mask.split('/')[0]
                container_map[name] = ip

            # Output as JSON for Ansible
            print(json.dumps(container_map))

        except Exception as e:
            print(f"Error parsing Podman network data: {e}", file=sys.stderr)
            print("{}")  # Output empty dict as fallback
  register: __container_ip_extraction
  changed_when: false
  failed_when: false  # Don't fail, use fallback
  when:
    - __podman_network_info is defined
    - __podman_network_info is not skipped
    - __podman_network_info.stdout is defined
    - (dirsrv_target_type | default('vm')) == 'container'
    - (dirsrv_network_validate | default(true)) | bool

- name: Preflight | Set container network mapping fact
  ansible.builtin.set_fact:
    __container_network_map: >-
      {%- if __container_ip_extraction is defined and __container_ip_extraction is not skipped and __container_ip_extraction.rc == 0 -%}
        {{ __container_ip_extraction.stdout | from_json }}
      {%- else -%}
        {}  {# Fallback to empty dict when Podman inspection fails or is skipped #}
      {%- endif -%}
  when:
    - __container_ip_extraction is defined
    - (dirsrv_target_type | default('vm')) == 'container'
    - (dirsrv_network_validate | default(true)) | bool
  tags: [preflight, network_validation]

- name: Preflight | Validate replication targets against container network
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import socket
        import sys
        import json

        hostname = '{{ dirsrv_repl_nodes[item].host }}'
        expected_name = '{{ item }}'

        # Get authoritative IP from Podman network inspection
        container_map = {{ __container_network_map | to_json }}
        authoritative_ip = container_map.get(expected_name)

        if not authoritative_ip:
            if container_map:  # Podman inspection worked but container not found
                print(f"âŒ Container '{expected_name}' not found in Podman network")
                print(f"Available containers: {list(container_map.keys())}")
                sys.exit(1)
            else:  # Podman inspection failed (e.g., running inside container)
                print(f"â„¹ï¸ Podman network inspection not available, skipping IP validation")
                print(f"   Proceeding with DNS resolution and connectivity tests only")
                authoritative_ip = None

        print(f"ðŸ” Checking {hostname} (container: {expected_name})")
        print(f"ðŸ“‹ Authoritative IP from Podman: {authoritative_ip}")

        dns_works = False
        ip_connectivity_works = False

        try:
            # Test DNS resolution
            resolved_ip = socket.gethostbyname(hostname)
            print(f"ðŸŒ DNS resolution: {hostname} -> {resolved_ip}")
            dns_works = True

            # Validate against authoritative source (only if we have authoritative data)
            if authoritative_ip and resolved_ip != authoritative_ip:
                print(f"ðŸš¨ IP MISMATCH DETECTED!")
                print(f"   Podman network says: {authoritative_ip}")
                print(f"   DNS resolves to:     {resolved_ip}")
                print(f"   â†’ This indicates /etc/hosts conflicts or DNS issues")
                sys.exit(1)

            print(f"âœ… IP validation passed: {resolved_ip}")
            sys.exit(0)

        except socket.gaierror as e:
            print(f"âš ï¸ DNS resolution failed: {hostname} - {e}")
            print(f"   â†’ This is OK in Podman environments, will test IP connectivity directly")
        except Exception as e:
            print(f"âŒ Validation failed: {e}")
            sys.exit(1)

        # Test IP connectivity
        if authoritative_ip:
            # Test with authoritative IP from Podman
            test_ip = authoritative_ip
            test_description = f"authoritative IP {authoritative_ip}"
        elif dns_works:
            # Use the resolved IP from DNS since we don't have authoritative data
            # We already resolved it above, so resolve again for consistency
            try:
                test_ip = socket.gethostbyname(hostname)
                test_description = f"DNS-resolved IP {test_ip}"
            except:
                print(f"âš ï¸ Cannot resolve {hostname} for connectivity test")
                test_ip = None
        else:
            print(f"âš ï¸ Skipping IP connectivity test (no IP available)")
            test_ip = None

        if test_ip:
            try:
                print(f"ðŸ”Œ Testing TCP connectivity to {test_description}:{{ dirsrv_repl_nodes[item].port }}")
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                result = sock.connect_ex((test_ip, {{ dirsrv_repl_nodes[item].port }}))
                sock.close()

                if result == 0:
                    print(f"âœ… TCP connection successful: {test_ip}:{{ dirsrv_repl_nodes[item].port }}")
                    ip_connectivity_works = True
                else:
                    print(f"âŒ TCP connection failed: {test_ip}:{{ dirsrv_repl_nodes[item].port }}")
                    print(f"   â†’ Target server may not be running or network is blocked")
                    sys.exit(1)
            except Exception as e:
                print(f"âŒ TCP connectivity test failed: {e}")
                sys.exit(1)
        else:
            # No IP to test, but if we got here with working DNS, that's still a partial success
            if dns_works:
                print(f"âš ï¸ DNS resolution works but cannot test IP connectivity")
                ip_connectivity_works = True  # Consider it working since DNS works
            else:
                print(f"âŒ Cannot test connectivity: no IP available and DNS failed")
                sys.exit(1)

        # Determine validation result
        if dns_works and ip_connectivity_works:
            print(f"âœ… Full validation passed: DNS + IP connectivity OK")
            sys.exit(0)
        elif not dns_works and ip_connectivity_works:
            print(f"âš ï¸ DNS resolution failed but IP connectivity works")
            print(f"   â†’ This is normal in some container environments")
            print(f"   â†’ Network validation passed based on IP connectivity")
            sys.exit(0)
        else:
            print(f"âŒ Network validation failed: No connectivity to {hostname}")
            sys.exit(1)
  register: __network_validation
  changed_when: false
  failed_when: __network_validation.rc != 0
  loop: "{{ __dirsrv_unique_targets | default([]) }}"
  when:
    - __container_network_map is defined
    - __dirsrv_unique_targets is defined
    - __dirsrv_unique_targets | length > 0
    - (dirsrv_target_type | default('vm')) == 'container'
    - (dirsrv_network_validate | default(true)) | bool
  tags: [preflight, network_validation]

- name: Preflight | Quick /etc/hosts conflict check (fallback if Podman inspection fails)
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import socket
        import sys

        conflicts_found = []

        try:
            with open('/etc/hosts', 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        parts = line.split()
                        if len(parts) >= 2:
                            hosts_ip = parts[0]
                            hostnames = parts[1:]

                            for hostname in hostnames:
                                if hostname not in ['localhost', 'localhost.localdomain']:
                                    try:
                                        resolved_ip = socket.gethostbyname(hostname)
                                        if resolved_ip != hosts_ip:
                                            conflicts_found.append({
                                                'hostname': hostname,
                                                'hosts_ip': hosts_ip,
                                                'resolved_ip': resolved_ip,
                                                'line': line_num
                                            })
                                    except socket.gaierror:
                                        # DNS resolution failed - this might be expected in some cases
                                        pass

        except Exception as e:
            print(f"Warning: Could not check /etc/hosts: {e}")
            sys.exit(0)

        if conflicts_found:
            print("ðŸš¨ CRITICAL: IP address conflicts detected in /etc/hosts!")
            print("This will cause replication connectivity failures.")
            print("")
            for conflict in conflicts_found:
                print(f"âŒ Line {conflict['line']}: {conflict['hostname']}")
                print(f"   /etc/hosts says: {conflict['hosts_ip']}")
                print(f"   DNS resolves to: {conflict['resolved_ip']}")
                print(f"   â†’ FIX: Remove or correct the entry in /etc/hosts")
                print("")
            print("ðŸ’¡ This commonly happens with Podman's extra_hosts configuration")
            print("   when hardcoded IPs don't match actual container IPs.")
            sys.exit(1)
        else:
            print("âœ… No IP address conflicts detected in /etc/hosts")
            sys.exit(0)
  register: hosts_conflict_check
  changed_when: false
  failed_when: hosts_conflict_check.rc != 0
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - (dirsrv_target_type | default('vm')) == 'container'
    - (dirsrv_network_validate | default(true)) | bool
    - __podman_network_info is defined
    - (__podman_network_info is failed or (__podman_network_info.rc is defined and __podman_network_info.rc != 0) or __podman_network_info is skipped)
  tags: [preflight, ip_validation]


- name: Preflight | Bind ping to replication targets with native ldapsearch
  vars:
    agree: "{{ item.1 }}"
    target: "{{ dirsrv_repl_nodes[agree.to] }}"
    _proto: "{{ target.protocol | lower }}"
    _url: "{{ _proto }}://{{ target.host }}:{{ target.port }}"
    _max_tries: 5
  ansible.builtin.command:
    argv:
      - ldapsearch
      - -x
      - -D
      - "{{ dirsrv_repl_auth.bind_dn }}"
      - -w
      - "{{ dirsrv_repl_auth.bind_password }}"
      - -H
      - "{{ _url }}"
      - -s
      - base
      - -b
      - ""
      - -l
      - "10"
      - "(objectClass=*)"
      - "1.1"
  register: __dirsrv_bind_ping
  changed_when: false
  failed_when: __dirsrv_bind_ping.rc != 0
  no_log: true
  until: __dirsrv_bind_ping.rc == 0
  retries: "{{ _max_tries }}"
  delay: 3
  with_subelements:
    - "{{ dirsrv_repl_agreements | default({}) | dict2items }}"
    - value
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - dirsrv_repl_nodes is defined
    - dirsrv_repl_auth is defined
    - dirsrv_repl_auth.method | default('SIMPLE') == 'SIMPLE'
    - item.1.from == inventory_hostname
  tags: [preflight]
