---
- name: Define dsconf candidate paths
  ansible.builtin.set_fact:
    dirsrv_dsconf_candidates:
      - /usr/sbin/dsconf
      - /sbin/dsconf
      - dsconf
  tags: [preflight]

- name: Stat dsconf candidates
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dirsrv_dsconf_candidates }}"
  register: dirsrv_dsconf_stats
  tags: [preflight]

- name: Assert dsconf is present
  ansible.builtin.assert:
    that:
      - (dirsrv_dsconf_stats.results | selectattr('stat.exists', 'equalto', true) | list | length) > 0
    fail_msg: "dsconf not found. Ensure 389-DS tools are installed."
  tags: [preflight]

- name: Select dsconf binary path
  ansible.builtin.set_fact:
    dirsrv_dsconf_bin: "{{ (dirsrv_dsconf_stats.results | selectattr('stat.exists', 'equalto', true) | map(attribute='stat.path') | list | first) | default('dsconf') }}"
  tags: [preflight]

- name: Probe dsconf export help
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsconf_bin }}", "{{ dirsrv_instance }}", "backend", "export", "--help"]
  register: dirsrv_src_dsconf_export_help
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Probe dsconf import help
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsconf_bin }}", "{{ dirsrv_instance }}", "backend", "import", "--help"]
  register: dirsrv_tgt_dsconf_import_help
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Derive dsconf capability flags
  ansible.builtin.set_fact:
    dirsrv_dsconf_supports_suffix: >-
      {{ ((dirsrv_src_dsconf_export_help.stdout | default('')) + ' ' + (dirsrv_src_dsconf_export_help.stderr | default(''))
          + ' ' + (dirsrv_tgt_dsconf_import_help.stdout | default('')) + ' ' + (dirsrv_tgt_dsconf_import_help.stderr | default(''))) is search('\\-\\-suffix') }}
    dirsrv_dsconf_supports_timeout_export: >-
      {{ ((dirsrv_src_dsconf_export_help.stdout | default('')) + ' ' + (dirsrv_src_dsconf_export_help.stderr | default(''))) is search('\\-\\-timeout') }}
    dirsrv_dsconf_supports_timeout_import: >-
      {{ ((dirsrv_tgt_dsconf_import_help.stdout | default('')) + ' ' + (dirsrv_tgt_dsconf_import_help.stderr | default(''))) is search('\\-\\-timeout') }}
  tags: [preflight]

- name: Build dsconf timeout argv (export)
  ansible.builtin.set_fact:
    dirsrv_dsconf_export_timeout_args: "{{ ['--timeout', (dirsrv_dsconf_timeout | string)] if (dirsrv_dsconf_supports_timeout_export | default(false)) else [] }}"
  tags: [preflight]

- name: Build dsconf timeout argv (import)
  ansible.builtin.set_fact:
    dirsrv_dsconf_import_timeout_args: "{{ ['--timeout', (dirsrv_dsconf_timeout | string)] if (dirsrv_dsconf_supports_timeout_import | default(false)) else [] }}"
  tags: [preflight]

# Optional discovery: effective instance/socket derived from dsctl when present
- name: Preflight | Discover dsctl candidates
  ansible.builtin.set_fact:
    dirsrv_dsctl_candidates:
      - /usr/sbin/dsctl
      - /sbin/dsctl
      - dsctl
  tags: [preflight]

- name: Preflight | Stat dsctl candidates
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dirsrv_dsctl_candidates }}"
  register: dirsrv_dsctl_stats
  changed_when: false
  tags: [preflight]

- name: Preflight | Select dsctl binary path
  ansible.builtin.set_fact:
    dirsrv_dsctl_bin: "{{ (dirsrv_dsctl_stats.results | selectattr('stat.exists', 'equalto', true) | map(attribute='stat.path') | list | first) | default('dsctl') }}"
  tags: [preflight]

- name: Preflight | Detect instances via dsctl -l
  ansible.builtin.command:
    argv: ["{{ dirsrv_dsctl_bin }}", "-l"]
  register: _dsctl_list
  changed_when: false
  failed_when: false
  tags: [preflight]

- name: Preflight | Derive detected instance name from dsctl output
  ansible.builtin.set_fact:
    _dirsrv_instance_detected: >-
      {{ (((_dsctl_list.stdout | default('')) | trim) == 'slapd-localhost')
          | ternary('localhost', 'dir') }}
  tags: [preflight]

- name: Preflight | Set effective instance
  ansible.builtin.set_fact:
    dirsrv_instance_effective: >-
      {{ (dirsrv_instance is defined and (dirsrv_instance | string | length) > 0)
          | ternary(dirsrv_instance, _dirsrv_instance_detected) }}
  tags: [preflight]

- name: Preflight | Set effective ldapi socket path
  ansible.builtin.set_fact:
    dirsrv_ldapi_socket_path_effective: >-
      {{ (dirsrv_ldapi_socket_path is defined and (dirsrv_ldapi_socket_path | string | length) > 0)
          | ternary(dirsrv_ldapi_socket_path,
                    '/var/run/dirsrv/slapd-' ~ (dirsrv_instance_effective) ~ '.socket') }}
  tags: [preflight]

# DNS/TCP gating for replication targets (runs when replication topology data present)
- name: Preflight | Collect replication targets
  ansible.builtin.set_fact:
    __dirsrv_unique_targets: "{{ (
        dirsrv_repl_agreements | default({})
        | dict2items
        | map(attribute='value')
        | flatten
        | selectattr('from', 'equalto', inventory_hostname)
        | map(attribute='to')
        | unique
        | list
      ) }}"
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - dirsrv_repl_nodes is defined
  tags: [preflight]

- name: Preflight | Get authoritative container network information from Podman
  ansible.builtin.command:
    argv:
      - podman
      - network
      - inspect
      - "{{ dirsrv_repl_network | default('dsnet') }}"
      - --format
      - json
  register: __podman_network_info
  changed_when: false
  failed_when: __podman_network_info.rc != 0
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
  tags: [preflight, network_validation]

- name: Preflight | Extract container IP mappings from Podman network
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import json
        import sys

        try:
            # Parse Podman network inspection output
            network_data = json.loads('{{ __podman_network_info.stdout | to_json }}')
            containers = network_data[0]['containers']

            # Build mapping of container names to IPs
            container_map = {}
            for container_id, container_info in containers.items():
                name = container_info['name']
                # Extract IP from eth0 interface (remove /24 subnet mask)
                ip_with_mask = container_info['interfaces']['eth0']['subnets'][0]['ipnet']
                ip = ip_with_mask.split('/')[0]
                container_map[name] = ip

            # Output as JSON for Ansible
            print(json.dumps(container_map))

        except Exception as e:
            print(f"Error parsing Podman network data: {e}", file=sys.stderr)
            sys.exit(1)
  register: __container_ip_extraction
  changed_when: false
  failed_when: __container_ip_extraction.rc != 0

- name: Preflight | Set container network mapping fact
  ansible.builtin.set_fact:
    __container_network_map: "{{ __container_ip_extraction.stdout | from_json }}"
  when:
    - __container_ip_extraction is defined
    - __container_ip_extraction.rc == 0
    - __podman_network_info is defined
    - __podman_network_info.rc == 0
  tags: [preflight, network_validation]

- name: Preflight | Validate replication targets against container network
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import socket
        import sys
        import json

        hostname = '{{ dirsrv_repl_nodes[item].host }}'
        expected_name = '{{ item }}'

        # Get authoritative IP from Podman network inspection
        container_map = {{ __container_network_map | to_json }}
        authoritative_ip = container_map.get(expected_name)

        if not authoritative_ip:
            print(f"❌ Container '{expected_name}' not found in Podman network")
            print(f"Available containers: {list(container_map.keys())}")
            sys.exit(1)

        print(f"🔍 Checking {hostname} (container: {expected_name})")
        print(f"📋 Authoritative IP from Podman: {authoritative_ip}")

        try:
            # Test DNS resolution
            resolved_ip = socket.gethostbyname(hostname)
            print(f"🌐 DNS resolution: {hostname} -> {resolved_ip}")

            # Validate against authoritative source
            if resolved_ip != authoritative_ip:
                print(f"🚨 IP MISMATCH DETECTED!")
                print(f"   Podman network says: {authoritative_ip}")
                print(f"   DNS resolves to:     {resolved_ip}")
                print(f"   → This indicates /etc/hosts conflicts or DNS issues")
                sys.exit(1)

            print(f"✅ IP validation passed: {resolved_ip}")
            sys.exit(0)

        except socket.gaierror as e:
            print(f"❌ DNS resolution failed: {hostname} - {e}")
            print(f"💡 Check container DNS configuration or /etc/hosts conflicts")
            sys.exit(1)
        except Exception as e:
            print(f"❌ Validation failed: {e}")
            sys.exit(1)
  register: __network_validation
  changed_when: false
  failed_when: __network_validation.rc != 0
  loop: "{{ __dirsrv_unique_targets | default([]) }}"
  when:
    - __container_network_map is defined
    - __dirsrv_unique_targets is defined
    - __dirsrv_unique_targets | length > 0
  tags: [preflight, network_validation]

- name: Preflight | Quick /etc/hosts conflict check (fallback if Podman inspection fails)
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import socket
        import sys

        conflicts_found = []

        try:
            with open('/etc/hosts', 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        parts = line.split()
                        if len(parts) >= 2:
                            hosts_ip = parts[0]
                            hostnames = parts[1:]

                            for hostname in hostnames:
                                if hostname not in ['localhost', 'localhost.localdomain']:
                                    try:
                                        resolved_ip = socket.gethostbyname(hostname)
                                        if resolved_ip != hosts_ip:
                                            conflicts_found.append({
                                                'hostname': hostname,
                                                'hosts_ip': hosts_ip,
                                                'resolved_ip': resolved_ip,
                                                'line': line_num
                                            })
                                    except socket.gaierror:
                                        # DNS resolution failed - this might be expected in some cases
                                        pass

        except Exception as e:
            print(f"Warning: Could not check /etc/hosts: {e}")
            sys.exit(0)

        if conflicts_found:
            print("🚨 CRITICAL: IP address conflicts detected in /etc/hosts!")
            print("This will cause replication connectivity failures.")
            print("")
            for conflict in conflicts_found:
                print(f"❌ Line {conflict['line']}: {conflict['hostname']}")
                print(f"   /etc/hosts says: {conflict['hosts_ip']}")
                print(f"   DNS resolves to: {conflict['resolved_ip']}")
                print(f"   → FIX: Remove or correct the entry in /etc/hosts")
                print("")
            print("💡 This commonly happens with Podman's extra_hosts configuration")
            print("   when hardcoded IPs don't match actual container IPs.")
            sys.exit(1)
        else:
            print("✅ No IP address conflicts detected in /etc/hosts")
            sys.exit(0)
  register: hosts_conflict_check
  changed_when: false
  failed_when: hosts_conflict_check.rc != 0
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - __podman_network_info is failed or __podman_network_info.rc != 0
  tags: [preflight, ip_validation]


- name: Preflight | Bind ping to replication targets with native ldapsearch
  vars:
    agree: "{{ item.1 }}"
    target: "{{ dirsrv_repl_nodes[agree.to] }}"
    _proto: "{{ target.protocol | lower }}"
    _url: "{{ _proto }}://{{ target.host }}:{{ target.port }}"
    _max_tries: 5
  ansible.builtin.command:
    argv:
      - ldapsearch
      - -x
      - -D
      - "{{ dirsrv_repl_auth.bind_dn }}"
      - -w
      - "{{ dirsrv_repl_auth.bind_password }}"
      - -H
      - "{{ _url }}"
      - -s
      - base
      - -b
      - ""
      - -l
      - "10"
      - "(objectClass=*)"
      - "1.1"
  register: __dirsrv_bind_ping
  changed_when: false
  failed_when: __dirsrv_bind_ping.rc != 0
  no_log: true
  until: __dirsrv_bind_ping.rc == 0
  retries: "{{ _max_tries }}"
  delay: 3
  with_subelements:
    - "{{ dirsrv_repl_agreements | default({}) | dict2items }}"
    - value
  when:
    - dirsrv_repl_agreements is defined
    - dirsrv_repl_agreements | length > 0
    - dirsrv_repl_nodes is defined
    - dirsrv_repl_auth is defined
    - dirsrv_repl_auth.method | default('SIMPLE') == 'SIMPLE'
    - item.1.from == inventory_hostname
  tags: [preflight]
