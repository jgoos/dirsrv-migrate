---
# yamllint disable rule:line-length

- name: Ensure local artifact root directory exists
  ansible.builtin.file:
    path: "{{ dirsrv_artifact_root_effective }}"
    state: directory
    mode: "0750"
  connection: local
  delegate_to: localhost
  become: false

- name: Ensure local artifact directory exists for this source
  ansible.builtin.file:
    path: "{{ [dirsrv_artifact_root_effective, inventory_hostname] | path_join }}"
    state: directory
    mode: "0750"
  connection: local
  delegate_to: localhost
  become: false

- name: Stop LDAP instance (offline export)
  ansible.builtin.systemd:
    name: "dirsrv@{{ dirsrv_instance }}"
    state: stopped
  when: dirsrv_manage_service | bool and dirsrv_export_offline | bool

- name: Ensure LDIF directory exists on source
  ansible.builtin.file:
    path: "{{ dirsrv_base_varldif }}"
    state: directory
    mode: "0750"
    owner: dirsrv
    group: dirsrv

- name: Gather existing source backends
  ansible.builtin.command:
    argv:
      - "{{ dirsrv_dsconf_bin | default('dsconf') }}"
      - "{{ dirsrv_instance }}"
      - backend
      - get-tree
  register: _dirsrv_source_backend_tree
  changed_when: false
  failed_when: _dirsrv_source_backend_tree.rc != 0
  when: dirsrv_manage_source_backends | bool and not ansible_check_mode

- name: Check source backends
  ansible.builtin.command:
    argv:
      - /bin/grep
      - -F
      - "{{ dirsrv_backends[item].suffix }}"
  args:
    stdin: "{{ _dirsrv_source_backend_tree.stdout }}"
  register: _dirsrv_source_backend_grep
  loop: "{{ dirsrv_backends.keys() | list }}"
  changed_when: false
  failed_when: _dirsrv_source_backend_grep.rc not in [0, 1]
  when: dirsrv_manage_source_backends | bool and not ansible_check_mode

- name: Create missing source backends
  ansible.builtin.command:
    argv:
      - "{{ dirsrv_dsconf_bin | default('dsconf') }}"
      - "{{ dirsrv_instance }}"
      - backend
      - create
      - --suffix
      - "{{ dirsrv_backends[item].suffix }}"
      - --be-name
      - "{{ item }}"
  register: _dirsrv_source_backend_create
  loop: "{{ dirsrv_backends.keys() | list }}"
  loop_control:
    index_var: idx
  changed_when: _dirsrv_source_backend_create.rc == 0
  failed_when: _dirsrv_source_backend_create.rc != 0
  when: dirsrv_manage_source_backends | bool and not ansible_check_mode and _dirsrv_source_backend_grep.results[idx].rc == 1

- name: Export via dsconf using --suffix (preferred)
  ansible.builtin.command:
    argv: "{{ [ dirsrv_dsconf_bin | default('dsconf'), dirsrv_instance, 'backend', 'export']
              + (dirsrv_dsconf_export_timeout_args | default([]))
              + ['--suffix', dirsrv_backends[item].suffix, '-l', ([dirsrv_base_varldif, 'migration-' ~ item ~ '.ldif'] | path_join)] }}"
  loop: "{{ dirsrv_backends.keys() | list }}"
  register: _dirsrv_export_preferred
  changed_when: false
  when: dirsrv_export_method == 'dsconf' and (dirsrv_dsconf_supports_suffix | default(false)) and not ansible_check_mode
  tags: [export]

- name: Export via dsconf using positional suffix (fallback)
  ansible.builtin.command:
    argv: "{{ [ dirsrv_dsconf_bin | default('dsconf'), dirsrv_instance, 'backend', 'export']
              + (dirsrv_dsconf_export_timeout_args | default([]))
              + ['-l', ([dirsrv_base_varldif, 'migration-' ~ item ~ '.ldif'] | path_join), dirsrv_backends[item].suffix] }}"
  loop: "{{ dirsrv_backends.keys() | list }}"
  register: _dirsrv_export_positional
  changed_when: false
  when: dirsrv_export_method == 'dsconf' and not (dirsrv_dsconf_supports_suffix | default(false)) and not ansible_check_mode
  tags: [export]

# SECURITY NOTE: This is a fallback/test method. In production environments,
# use dirsrv_export_method: 'dsconf' instead. If ldapsearch must be used,
# ensure dirsrv_password is stored in Ansible Vault (group_vars/all/vault.yml)
# and never committed to version control. Shell commands with passwords should
# be avoided when possible; prefer command module with argv for better security.
- name: Export LDIF via ldapsearch (fallback/test)
  ansible.builtin.shell: >-
    LDAPTLS_REQCERT=never
    ldapsearch -x -H '{{ dirsrv_ldap_tcp_uri }}' \
      -D 'cn=Directory Manager' -w '{{ dirsrv_password }}' \
      -b '{{ dirsrv_backends[item].suffix }}' '(objectClass=*)' -LLL \
      > '{{ [dirsrv_base_varldif, 'migration-' ~ item ~ '.ldif'] | path_join }}'
  args:
    executable: /bin/sh
  loop: "{{ dirsrv_backends.keys() | list }}"
  register: _dirsrv_export_ldapsearch
  changed_when: false
  when: dirsrv_export_method == 'ldapsearch' and not ansible_check_mode
  tags: [export]
  no_log: true

- name: Snapshot | Ensure local artifacts dir exists (controller)
  ansible.builtin.file:
    path: "{{ [dirsrv_artifact_root_effective, inventory_hostname] | path_join }}"
    state: directory
    mode: "0750"
  connection: local
  delegate_to: localhost
  become: false
  when: dirsrv_debug | bool

- name: Snapshot | Export command results (test-only)
  vars:
    res: "{{ item }}"
    backend: "{{ item.item }}"
    __snap_dir: "{{ [dirsrv_artifact_root_effective, inventory_hostname] | path_join }}"
    __raw_cmd: "{{ (res.cmd | default('')) | string }}"
    __san_cmd: "{{ __raw_cmd | regex_replace('(?i)(-w) +[^ ]+', '-w ****') }}"
    __parts: "{{ (res.delta | default('0:0:0.0')) | regex_findall('([0-9]+)') }}"
    __dur_ms: "{{ (__parts[0] | default('0') | int) * 3600000 + (__parts[1] | default('0') | int) * 60000 + (__parts[2] | default('0') | int) * 1000 + ((__parts[3] | default('0') | int) // 1000) }}"
  ansible.builtin.copy:
    content: |
      {{ {
          'host': inventory_hostname,
          'step': 'export-' ~ (backend | regex_replace('[^A-Za-z0-9_.-]','_')),
          'ts': (ansible_date_time.iso8601_micro | default("%Y-%m-%dT%H:%M:%SZ" | strftime)),
          'argv_redacted': __san_cmd,
          'rc': res.rc | default(-1),
          'stdout_excerpt': (res.stdout | default(''))[:2048],
          'stderr_excerpt': (res.stderr | default(''))[:2048],
          'duration_ms': __dur_ms
        } | to_nice_json }}
    dest: "{{ [__snap_dir, 'cmd-export-' ~ (backend | regex_replace('[^A-Za-z0-9_.-]','_')) ~ '.json'] | path_join }}"
    mode: "0640"
  connection: local
  delegate_to: localhost
  become: false
  loop: "{{ (_dirsrv_export_preferred.results | default([])) + (_dirsrv_export_positional.results | default([])) + (_dirsrv_export_ldapsearch.results | default([])) }}"
  when: dirsrv_debug | bool

- name: Fetch the LDIF dumps
  ansible.builtin.fetch:
    dest: "{{ [dirsrv_artifact_root_effective, inventory_hostname, ''] | path_join }}"  # ensure trailing slash
    flat: true
    src: "{{ [dirsrv_base_varldif, 'migration-' ~ item ~ '.ldif'] | path_join }}"
  loop: "{{ dirsrv_backends.keys() | list }}"
  when: not ansible_check_mode
  tags: [artifacts]

- name: Fix permissions on LDIF dumps
  ansible.builtin.file:
    path: "{{ [dirsrv_artifact_root_effective, inventory_hostname, 'migration-' ~ item ~ '.ldif'] | path_join }}"
    mode: "0640"
  connection: local
  delegate_to: localhost
  become: false
  loop: "{{ dirsrv_backends.keys() | list }}"
  when: not ansible_check_mode
  tags: [artifacts]

- name: Build list of local LDIF artifact paths (controller)
  ansible.builtin.set_fact:
    dirsrv_local_ldif_files: "{{ dirsrv_backends.keys() | list | map('regex_replace', '^(.*)$', ([dirsrv_artifact_root_effective, inventory_hostname, 'migration-' ~ '\\1' ~ '.ldif'] | path_join)) | list }}"
  connection: local
  delegate_to: localhost
  become: false

## Split LDIFs: create cleaned + removed; gzip original and removed (controller)
- name: Stat local LDIF artifacts before split (controller)
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ dirsrv_local_ldif_files | default([]) }}"
  register: _ldif_local_stat
  connection: local
  delegate_to: localhost
  become: false

- name: Build list of existing local LDIFs (controller)
  ansible.builtin.set_fact:
    dirsrv_local_ldif_files_existing: "{{ _ldif_local_stat.results | default([]) | selectattr('stat.exists', 'defined') | selectattr('stat.exists') | map(attribute='item') | list }}"
  connection: local
  delegate_to: localhost
  become: false

- name: Count entries in original LDIFs (controller)
  ansible.builtin.command:
    argv: ["grep", "-Eic", "^dn::?", "{{ item }}"]
  loop: "{{ dirsrv_local_ldif_files_existing | default([]) }}"
  register: _ldif_pre_counts
  changed_when: false
  failed_when: _ldif_pre_counts.rc > 1  # allow rc=1 (no matches)
  connection: local
  delegate_to: localhost
  become: false

- name: Split LDIF (clean vs removed) and compress artifacts (controller)
  ldif_filter_split:
    src: "{{ item }}"
    clean: "{{ item | regex_replace('\\.ldif$', '.cleaned.ldif') }}"
    removed: "{{ item | regex_replace('\\.ldif$', '.removed.ldif') }}"
    dn_regex_any:
      - "^cn=repl"
    oc_all:
      - ["ldapsubentry", "extensibleObject"]
    compress_removed: true
    compress_orig: true
  loop: "{{ dirsrv_local_ldif_files_existing | default([]) }}"
  when: not ansible_check_mode
  connection: local
  delegate_to: localhost
  become: false
  register: _ldif_split_results
  tags: [artifacts]

- name: Log split results (kept vs removed)
  ansible.builtin.debug:
    msg:
      - "File: {{ item.item }}"
      - "Kept entries: {{ item.kept | default('n/a') }}"
      - "Removed entries: {{ item.removed | default('n/a') }}"
      - "Clean: {{ item.clean | default('n/a') }}"
      - "Removed file: {{ item.removed_file | default('n/a') }}"
      - "Original gz: {{ item.orig_compressed | default('n/a') }}"
  loop: "{{ _ldif_split_results.results | default([]) }}"
  when: _ldif_split_results is defined
  connection: local
  delegate_to: localhost
  become: false

- name: Build list of cleaned LDIF artifact paths (controller)
  ansible.builtin.set_fact:
    dirsrv_local_ldif_files_cleaned: "{{ (dirsrv_local_ldif_files_existing | default([])) | map('regex_replace', '\\.(ldif)$', '.cleaned.\\1') | list }}"
  connection: local
  delegate_to: localhost
  become: false

- name: Count entries in cleaned LDIFs (controller)
  ansible.builtin.command:
    argv: ["grep", "-Eic", "^dn::?", "{{ item }}"]
  loop: "{{ dirsrv_local_ldif_files_cleaned | default([]) }}"
  register: _ldif_clean_counts
  changed_when: false
  failed_when: _ldif_clean_counts.rc > 1  # allow rc=1 (no matches)
  when: not ansible_check_mode
  connection: local
  delegate_to: localhost
  become: false

- name: Assert LDIF counts match (original vs kept/removed vs cleaned)
  ansible.builtin.assert:
    that:
      - ((_ldif_pre_counts.results[idx].stdout | default('0')) | int) == (((_ldif_split_results.results[idx].kept | default(0)) | int) + ((_ldif_split_results.results[idx].removed | default(0)) | int))
      - ((_ldif_clean_counts.results[idx].stdout | default('0')) | int) == ((_ldif_split_results.results[idx].kept | default(0)) | int)
    fail_msg: >-
      LDIF count mismatch for {{ dirsrv_local_ldif_files_existing[idx] }}:
      pre={{ (_ldif_pre_counts.results[idx].stdout | default('0')) | int }},
      kept={{ (_ldif_split_results.results[idx].kept | default(0)) | int }},
      removed={{ (_ldif_split_results.results[idx].removed | default(0)) | int }},
      cleaned={{ (_ldif_clean_counts.results[idx].stdout | default('0')) | int }}
  loop: "{{ range(0, (dirsrv_local_ldif_files_existing | default([]) | length)) | list }}"
  loop_control:
    index_var: idx
  when: not ansible_check_mode and (dirsrv_local_ldif_files_existing | default([]) | length) > 0
  connection: local
  delegate_to: localhost
  become: false

- name: Clean exported LDIF artifacts with configured patterns (controller)
  ansible.builtin.replace:
    backup: true
    path: "{{ item.0 }}"
    regexp: "{{ item.1.regexp }}"
    replace: "{{ item.1.replace | default('') }}"
  loop: "{{ (dirsrv_local_ldif_files_cleaned | default([])) | product(dirsrv_cleanup_patterns_data | default([])) | list }}"
  connection: local
  delegate_to: localhost
  become: false
  when: not ansible_check_mode
  tags: [artifacts]

- name: Create archive of instance config
  ansible.builtin.command:
    argv:
      - /bin/tar
      - cjf
      - "{{ [dirsrv_tempdir, 'dirsrv_slapd-' ~ dirsrv_instance ~ '.tar.bz2'] | path_join }}"
      - "{{ dirsrv_base_config }}"
  changed_when: false
  when: dirsrv_collect_config | bool and not ansible_check_mode
  tags: [artifacts]

- name: Fetch the config archive
  ansible.builtin.fetch:
    src: "{{ [dirsrv_tempdir, 'dirsrv_slapd-' ~ dirsrv_instance ~ '.tar.bz2'] | path_join }}"
    dest: "{{ [dirsrv_artifact_root_effective, inventory_hostname, ''] | path_join }}"  # ensure trailing slash
    flat: true
  when: dirsrv_collect_config | bool and not ansible_check_mode
  tags: [artifacts]

- name: Fix permissions on config archive
  ansible.builtin.file:
    path: "{{ [dirsrv_artifact_root_effective, inventory_hostname, 'dirsrv_slapd-' ~ dirsrv_instance ~ '.tar.bz2'] | path_join }}"
    mode: "0640"
  connection: local
  delegate_to: localhost
  become: false
  when: dirsrv_collect_config | bool and not ansible_check_mode
  tags: [artifacts]

- name: Start LDAP instance (offline export)
  ansible.builtin.systemd:
    name: "dirsrv@{{ dirsrv_instance }}"
    state: started
  when: dirsrv_manage_service | bool and dirsrv_export_offline | bool

- name: Remove archive of instance config on source
  ansible.builtin.file:
    path: "{{ [dirsrv_tempdir, 'dirsrv_slapd-' ~ dirsrv_instance ~ '.tar.bz2'] | path_join }}"
    state: absent
  when: dirsrv_collect_config | bool and not ansible_check_mode
