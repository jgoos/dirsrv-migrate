---
- name: Preflight | Ensure dsconf/dsctl available
  block:
    - name: Preflight | Stat dsconf candidates
      ansible.builtin.stat:
        path: "{{ item }}"
      register: dirsrv_repl_dsconf_stats
      loop:
        - /usr/sbin/dsconf
        - /sbin/dsconf
        - dsconf
      changed_when: false

    - name: Preflight | Assert dsconf present
      ansible.builtin.assert:
        that:
          - (dirsrv_repl_dsconf_stats.results | selectattr('stat.exists','equalto', true) | list | length) > 0
        fail_msg: "dsconf not found in PATH or standard locations"

    - name: Preflight | Stat dsctl candidates
      ansible.builtin.stat:
        path: "{{ item }}"
      register: dirsrv_repl_dsctl_stats
      loop:
        - /usr/sbin/dsctl
        - /sbin/dsctl
        - dsctl
      changed_when: false

    - name: Preflight | Assert dsctl present
      ansible.builtin.assert:
        that:
          - (dirsrv_repl_dsctl_stats.results | selectattr('stat.exists','equalto', true) | list | length) > 0
        fail_msg: "dsctl not found in PATH or standard locations"

- name: Preflight | Service facts for time sync check
  ansible.builtin.service_facts:

- name: Preflight | Warn if time sync service inactive (chronyd/ntpd/timesyncd)
  ansible.builtin.debug:
    msg: "Time sync service not active (chronyd/ntpd/systemd-timesyncd). Replication CSNs require correct time."
    warn: true
  when: >-
    (ansible_facts.services is defined) and not (
      ('chronyd.service' in ansible_facts.services and ansible_facts.services['chronyd.service'].state == 'running') or
      ('ntpd.service' in ansible_facts.services and ansible_facts.services['ntpd.service'].state == 'running') or
      ('systemd-timesyncd.service' in ansible_facts.services and ansible_facts.services['systemd-timesyncd.service'].state == 'running')
    )

- name: Preflight | Validate local node definition exists
  ansible.builtin.assert:
    that:
      - dirsrv_repl_nodes is mapping
      - dirsrv_repl_nodes[inventory_hostname] is defined
      - dirsrv_repl_nodes[inventory_hostname].role in ['supplier','consumer','hub']
      - dirsrv_repl_nodes[inventory_hostname].instance is string
      - dirsrv_repl_nodes[inventory_hostname].host is string
      - dirsrv_repl_nodes[inventory_hostname].port is number
      - dirsrv_repl_nodes[inventory_hostname].protocol in ['LDAP','LDAPS']
    fail_msg: "Define dirsrv_repl_nodes[{{ inventory_hostname }}] with role/instance/host/port/protocol"

- name: Preflight | Set fact - local node
  ansible.builtin.set_fact:
    dirsrv_repl_this_node: "{{ dirsrv_repl_nodes[inventory_hostname] }}"

- name: Preflight | Validate unique replica IDs across suppliers/hubs (controller)
  ansible.builtin.assert:
    that:
      - >-
        not dirsrv_repl_require_unique_replica_ids | bool or
        (
          (dirsrv_repl_replica_ids[item] | default({}) | dict2items | map(attribute='value') | list | length)
          ==
          (dirsrv_repl_replica_ids[item] | default({}) | dict2items | map(attribute='value') | list | unique | length)
        )
    fail_msg: "Replica IDs must be unique per suffix across suppliers/hubs (suffix={{ item }})"
  loop: "{{ dirsrv_repl_suffixes }}"
  run_once: true
  delegate_to: localhost
  vars:
    ansible_become: false

- name: Preflight | Build init=true pairs per suffix (controller)
  ansible.builtin.set_fact:
    dirsrv_repl_init_pairs: "{{ (dirsrv_repl_init_pairs | default([])) + [ { 'suffix': item.0.key, 'from': item.1.from, 'to': item.1.to } ] }}"
  with_subelements:
    - "{{ dirsrv_repl_agreements | dict2items }}"
    - value
  when:
    - dirsrv_repl_agreements | length > 0
    - item.1.init | default(false)
    - dirsrv_repl_guard_bidirectional_init | bool
  run_once: true
  delegate_to: localhost
  vars:
    ansible_become: false

- name: Preflight | Assert no bidirectional init for the same suffix (controller)
  ansible.builtin.assert:
    that:
      - "(dirsrv_repl_init_pairs | default([]) | selectattr('suffix','equalto', item.suffix) | selectattr('from','equalto', item.to) | selectattr('to','equalto', item.from) | list | length) == 0"
    fail_msg: "Bidirectional init detected for suffix {{ item.suffix }} between {{ item.from }} and {{ item.to }}. Disable one init or run sequentially."
  loop: "{{ dirsrv_repl_init_pairs | default([]) }}"
  run_once: true
  delegate_to: localhost
  vars:
    ansible_become: false

- name: Include enable tasks
  ansible.builtin.include_tasks: enable.yml

- name: Include agreements tasks
  ansible.builtin.include_tasks: agreements.yml

- name: Include init tasks
  ansible.builtin.include_tasks: init.yml

- name: Include tuning tasks
  ansible.builtin.include_tasks: tuning.yml

- name: Wait for agreements healthy
  ansible.builtin.include_tasks: wait_green.yml

- name: Include monitor tasks
  ansible.builtin.include_tasks: monitor.yml
