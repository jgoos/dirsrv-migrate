---
- name: Preflight | Include common preflight (tools, ldapi, DNS/TCP gating)
  ansible.builtin.include_role:
    name: dirsrv_common
    tasks_from: preflight

- name: Preflight | Ensure dsconf/dsctl available
  block:
    - name: Preflight | Stat dsconf candidates
      ansible.builtin.stat:
        path: "{{ item }}"
      register: dirsrv_repl_dsconf_stats
      loop:
        - /usr/bin/dsconf
        - /usr/sbin/dsconf
        - /sbin/dsconf
        - dsconf
      changed_when: false

    - name: Preflight | Assert dsconf present
      ansible.builtin.assert:
        that:
          - (dirsrv_repl_dsconf_stats.results | selectattr('stat.exists','equalto', true) | list | length) > 0
        fail_msg: "dsconf not found in PATH or standard locations"

    - name: Preflight | Stat dsctl candidates
      ansible.builtin.stat:
        path: "{{ item }}"
      register: dirsrv_repl_dsctl_stats
      loop:
        - /usr/bin/dsctl
        - /usr/sbin/dsctl
        - /sbin/dsctl
        - dsctl
      changed_when: false

    - name: Preflight | Assert dsctl present
      ansible.builtin.assert:
        that:
          - (dirsrv_repl_dsctl_stats.results | selectattr('stat.exists','equalto', true) | list | length) > 0
        fail_msg: "dsctl not found in PATH or standard locations"

- name: Preflight | Service facts for time sync check
  ansible.builtin.service_facts:

- name: Preflight | Warn if time sync service inactive (chronyd/ntpd/timesyncd)
  ansible.builtin.debug:
    msg: "Time sync service not active (chronyd/ntpd/systemd-timesyncd). Replication CSNs require correct time."

- name: Preflight | Validate container network configuration
  ansible.builtin.command:
    argv:
      - python3
      - -c
      - |
        import socket
        import sys
        import os

        # Check if we're running in a containerized environment
        try:
            with open('/proc/1/cgroup', 'r') as f:
                if 'containerd' in f.read() or 'docker' in f.read() or 'podman' in f.read():
                    print("✅ Running in containerized environment")

                    # Validate network configuration
                    hostname = socket.gethostname()
                    try:
                        local_ip = socket.gethostbyname(hostname)
                        print(f"Local hostname resolution: {hostname} -> {local_ip}")

                        # Check if IP is in expected range for container networks
                        ip_parts = local_ip.split('.')
                        if len(ip_parts) == 4:
                            # Common container network ranges
                            common_ranges = [
                                ('172', '16-31'),  # Docker default bridge
                                ('10', '0-255'),   # Common private networks
                                ('192', '168'),    # Private networks
                            ]

                            subnet = ip_parts[0]
                            if subnet in ['172', '10', '192']:
                                print(f"✅ IP address {local_ip} is in expected container network range")
                            else:
                                print(f"⚠️ IP address {local_ip} is not in typical container network range")
                        else:
                            print(f"⚠️ Unexpected IP format: {local_ip}")

                    except socket.gaierror as e:
                        print(f"❌ Cannot resolve local hostname: {e}")
                        sys.exit(1)

                    # Check /etc/hosts for suspicious entries
                    try:
                        with open('/etc/hosts', 'r') as f:
                            hosts_content = f.read()

                        lines = hosts_content.split('\n')
                        suspicious_lines = []
                        for line in lines:
                            line = line.strip()
                            if line and not line.startswith('#'):
                                parts = line.split()
                                if len(parts) >= 2:
                                    ip = parts[0]
                                    hostnames = parts[1:]
                                    # Check for hardcoded IPs that might conflict
                                    if ip.startswith(('172.', '10.', '192.')):
                                        # Look for hostnames that might have mismatched IPs
                                        for hostname in hostnames:
                                            try:
                                                resolved_ip = socket.gethostbyname(hostname)
                                                if resolved_ip != ip and hostname != 'localhost':
                                                    suspicious_lines.append(f"{hostname}: hosts={ip}, resolved={resolved_ip}")
                                            except:
                                                pass

                        if suspicious_lines:
                            print("⚠️ Potential IP address conflicts detected in /etc/hosts:")
                            for line in suspicious_lines:
                                print(f"  - {line}")
                            print("This may cause connectivity issues")
                        else:
                            print("✅ /etc/hosts configuration appears clean")

                    except Exception as e:
                        print(f"⚠️ Could not check /etc/hosts: {e}")

                    sys.exit(0)
                else:
                    print("ℹ️ Not running in containerized environment, skipping network validation")
                    sys.exit(0)
        except:
            print("ℹ️ Cannot determine environment, skipping network validation")
            sys.exit(0)
  register: network_validation
  changed_when: false
  failed_when: network_validation.rc != 0
  when: not ansible_check_mode
  tags: [preflight, network_validation]

- name: Preflight | Gather datetime facts (INT only)
  ansible.builtin.setup:
    filter: ansible_date_time
  when: env_type | default('dev') == 'int'

- name: Preflight | Assert timezone present (INT)
  ansible.builtin.assert:
    that:
      - ansible_date_time is defined
      - ansible_date_time.tz is defined
      - (ansible_date_time.tz | string | length) > 0
    fail_msg: "Timezone is not detected; ensure system clock/timezone configured (INT requires sane time)."
  when: env_type | default('dev') == 'int'

- name: Preflight | Assert time sync service active (INT)
  ansible.builtin.assert:
    that:
      - (
          ('chronyd.service' in ansible_facts.services and ansible_facts.services['chronyd.service'].state == 'running') or
          ('ntpd.service' in ansible_facts.services and ansible_facts.services['ntpd.service'].state == 'running') or
          ('systemd-timesyncd.service' in ansible_facts.services and ansible_facts.services['systemd-timesyncd.service'].state == 'running')
        )
    fail_msg: "NTP/chronyd/timesyncd not active; INT requires time sync to be running on all nodes."
  when:
    - env_type | default('dev') == 'int'
    - ansible_facts.services is defined

- name: Preflight | Include comprehensive health checks
  ansible.builtin.include_tasks: health_checks.yml
  when: not ansible_check_mode

- name: Preflight | Include mesh connectivity health checks
  ansible.builtin.include_tasks: mesh_health_checks.yml
  when:
    - not ansible_check_mode
    - dirsrv_repl_nodes is defined
    - (dirsrv_repl_nodes | length) > 1

## Monitoring setup moved later to ensure local node facts are set

- name: Preflight | Additional time sync warning
  ansible.builtin.debug:
    msg: "Time sync service not active (chronyd/ntpd/systemd-timesyncd). Replication CSNs require correct time."
    warn: true
  when: >-
    (ansible_facts.services is defined) and not (
      ('chronyd.service' in ansible_facts.services and ansible_facts.services['chronyd.service'].state == 'running') or
      ('ntpd.service' in ansible_facts.services and ansible_facts.services['ntpd.service'].state == 'running') or
      ('systemd-timesyncd.service' in ansible_facts.services and ansible_facts.services['systemd-timesyncd.service'].state == 'running')
    )

- name: Preflight | Validate local node definition exists
  ansible.builtin.assert:
    that:
      - dirsrv_repl_nodes is mapping
      - dirsrv_repl_nodes[inventory_hostname] is defined
      - dirsrv_repl_nodes[inventory_hostname].role in ['supplier','consumer','hub']
      - dirsrv_repl_nodes[inventory_hostname].instance is string
      - dirsrv_repl_nodes[inventory_hostname].host is string
      - dirsrv_repl_nodes[inventory_hostname].port is number
      - dirsrv_repl_nodes[inventory_hostname].protocol in ['LDAP','LDAPS']
    fail_msg: "Define dirsrv_repl_nodes[{{ inventory_hostname }}] with role/instance/host/port/protocol"

- name: Preflight | Set fact - local node
  ansible.builtin.set_fact:
    dirsrv_repl_this_node: "{{ dirsrv_repl_nodes[inventory_hostname] }}"

- name: Preflight | Validate unique replica IDs across suppliers/hubs (controller)
  ansible.builtin.assert:
    that:
      - >-
        not dirsrv_repl_require_unique_replica_ids | bool or
        (
          (dirsrv_repl_replica_ids[item] | default({}) | dict2items | map(attribute='value') | list | length)
          ==
          (dirsrv_repl_replica_ids[item] | default({}) | dict2items | map(attribute='value') | list | unique | length)
        )
    fail_msg: "Replica IDs must be unique per suffix across suppliers/hubs (suffix={{ item }})"
  loop: "{{ dirsrv_repl_suffixes }}"
  run_once: true
  delegate_to: localhost
  vars:
    ansible_become: false


- name: Include enable tasks
  ansible.builtin.include_tasks: enable.yml


- name: Include agreements tasks
  ansible.builtin.include_tasks: agreements.yml

- name: Include init tasks
  ansible.builtin.include_tasks: init.yml

- name: Include tuning tasks
  ansible.builtin.include_tasks: tuning.yml

- name: Wait for agreements healthy
  ansible.builtin.include_tasks: wait_green.yml

- name: Include monitor tasks
  ansible.builtin.include_tasks: monitor.yml
