diff a/docs/DESIGN.md b/docs/DESIGN.md	(rejected hunks)
@@ -64 +64 @@ This defines a bridge network dsnet with subnet 10.89.0.0/24. The Podman DNS plu
-Container DNS Names: We set the container hostnames to a stable fully-qualified domain (e.g. s1.dsnet.test). Internally, Podman’s DNS plugin (or Aardvark in newer Podman) will allow containers to resolve each other by hostname ￼ ￼. By default, the plugin uses a DNS domain like dns.podman ￼ or none at all, so to ensure our custom *.dsnet.test names resolve, we leverage network aliases. In the compose file, each service on the dsnet network will get an alias equal to its FQDN (e.g., alias s1.dsnet.test). This causes the DNS service to recognize that name. (We attempted to set a custom domain suffix via network options, but Podman doesn’t provide an easy CLI switch for that; the dnsname plugin can be configured with a domainName in the network’s config file ￼, but using aliases in compose is simpler and avoids manual CNI config edits.) As a fallback or additional measure, we could inject entries into each container’s /etc/hosts mapping s1.dsnet.test to the container’s IP, but using the built-in DNS is cleaner.
+Container DNS Names: We set the container hostnames to a stable fully-qualified domain (e.g. s1.dsnet.test). Internally, Podman’s DNS plugin (or Aardvark in newer Podman) will allow containers to resolve each other by hostname. By default, the plugin uses a DNS domain like dns.podman or none at all, so to ensure our custom *.dsnet.test names resolve, we leverage network aliases. In the compose file, each service on the dsnet network will get an alias equal to its FQDN (e.g., alias s1.dsnet.test). This causes the DNS service to recognize that name. We do not inject /etc/hosts entries; reliable DNS is a prerequisite and is enforced by preflight checks.
@@ -69,2 +69,2 @@ Host ↔ Container Connectivity: By default, in rootless Podman on macOS, contai
-	1.	Port Forwarding: We can publish container ports to the host. For example, we might publish s1’s LDAP port to macOS as 1389. Then an ldapsearch to localhost:1389 (or with an /etc/hosts entry mapping s1.dsnet.test to 127.0.0.1) would reach s1. In Podman Compose, we will by default avoid publishing (to keep containers isolated and to allow multiple instances of the lab without port conflicts), but we’ll demonstrate how to expose one master’s ports if needed for host-side testing.
-	2.	macOS DNS/Hosts: Alternatively, you could configure macOS to resolve *.dsnet.test via the Podman VM’s resolver. This is non-trivial – one could run a DNS server or use the Mac’s /etc/resolver feature to forward dsnet.test queries to the Podman VM’s IP (which runs the Aardvark DNS for container names). Given the complexity, using port forwarding + /etc/hosts entries on the Mac is simpler for occasional testing. For instance, add 127.0.0.1 s1.dsnet.test in /etc/hosts and publish s1’s LDAP port to 127.0.0.1:1389. This way you can connect to s1.dsnet.test:1389 from macOS. We will include guidance for such port mappings in the compose file comments.
+	1.	Port Forwarding: We can publish container ports to the host. For example, publish s1’s LDAP port to macOS as 1389 and connect to localhost:1389. In Podman Compose, we avoid publishing by default (to keep containers isolated and to allow multiple instances of the lab without port conflicts), but we’ll demonstrate how to expose one master’s ports if needed for host-side testing.
+	2.	macOS Resolvers: Optionally configure macOS to resolve *.dsnet.test via the Podman VM’s resolver (e.g., /etc/resolver). For ad‑hoc testing, prefer connecting to published localhost ports rather than editing /etc/hosts.
